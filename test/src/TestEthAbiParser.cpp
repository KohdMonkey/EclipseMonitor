// Copyright (c) 2022 Haofan Zheng
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

#include <cstdint>

#include <vector>

#include <gtest/gtest.h>

#include <EclipseMonitor/Eth/AbiParser.hpp>

namespace EclipseMonitor_Test
{
	extern size_t g_numOfTestFile;
}

using namespace EclipseMonitor_Test;
using namespace EclipseMonitor::Eth;

GTEST_TEST(TestEthAbiParser, CountTestFile)
{
	static auto tmp = ++EclipseMonitor_Test::g_numOfTestFile;
	(void)tmp;
}

GTEST_TEST(TestEthAbiParser, ParseIntegerPrimitive)
{
	{
		std::vector<uint8_t> input = {
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0xFFU,
		};
		auto expRes = std::make_tuple(
			static_cast<uint64_t>(0xFFULL),
			input.end()
		);

		auto actRes = AbiParser<SimpleObjects::ObjCategory::Integer>::
			ToPrimitive<SimpleObjects::RealNumType::UInt64>(
				input.begin(), input.end()
			);

		EXPECT_EQ(expRes, actRes);
	}

	{
		std::vector<uint8_t> input = {
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0xFEU, 0xDCU, 0xBAU, 0x98U, 0x76U, 0x54U, 0x32U, 0x10U,
		};
		auto expRes = std::make_tuple(
			static_cast<uint64_t>(0xFEDCBA9876543210ULL),
			input.end()
		);

		auto actRes = AbiParser<SimpleObjects::ObjCategory::Integer>::
			ToPrimitive<SimpleObjects::RealNumType::UInt64>(
				input.begin(), input.end()
			);

		EXPECT_EQ(expRes, actRes);
	}

	// Error - non-zero bytes in the skipped bytes
	{
		std::vector<uint8_t> input = {
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x01U,
			0xFEU, 0xDCU, 0xBAU, 0x98U, 0x76U, 0x54U, 0x32U, 0x10U,
		};

		auto testProg = [&input]() {
			AbiParser<SimpleObjects::ObjCategory::Integer>::
				ToPrimitive<SimpleObjects::RealNumType::UInt64>(
					input.begin(), input.end()
				);
		};

		EXPECT_THROW(testProg();, EclipseMonitor::Exception);
	}

	// Error - not enough input bytes
	{
		std::vector<uint8_t> input = {
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0xFEU, 0xDCU, 0xBAU, 0x98U, 0x76U, 0x54U, 0x32U, 0x10U,
		};

		auto testProg = [&input]() {
			AbiParser<SimpleObjects::ObjCategory::Integer>::
				ToPrimitive<SimpleObjects::RealNumType::UInt64>(
					input.begin(), input.end()
				);
		};

		input.resize(31);
		EXPECT_THROW(testProg();, EclipseMonitor::Exception);

		input.resize(15);
		EXPECT_THROW(testProg();, EclipseMonitor::Exception);
	}
}

GTEST_TEST(TestEthAbiParser, ParseBoolPrimitive)
{
	// false
	{
		std::vector<uint8_t> input = {
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
		};
		auto expRes = std::make_tuple(
			static_cast<bool>(false),
			input.end()
		);

		auto actRes = AbiParser<SimpleObjects::ObjCategory::Bool>::
			ToPrimitive(input.begin(), input.end());

		EXPECT_EQ(expRes, actRes);
	}

	// true
	{
		std::vector<uint8_t> input = {
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x01U,
		};
		auto expRes = std::make_tuple(
			static_cast<bool>(true),
			input.end()
		);

		auto actRes = AbiParser<SimpleObjects::ObjCategory::Bool>::
			ToPrimitive(input.begin(), input.end());

		EXPECT_EQ(expRes, actRes);
	}

	// invalid bool value
	{
		std::vector<uint8_t> input = {
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x02U,
		};

		auto testProg = [&input]() {
			AbiParser<SimpleObjects::ObjCategory::Bool>::
				ToPrimitive(input.begin(), input.end());
		};

		EXPECT_THROW(testProg();, EclipseMonitor::Exception);
	}
}

GTEST_TEST(TestEthAbiParser, ParseStaticBytesPrimitive)
{
	// bytes16
	{
		std::vector<uint8_t> input = {
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
			0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
		};
		auto expRes = std::make_tuple(
			std::vector<uint8_t>({
				0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
				0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
			}),
			input.end()
		);

		auto actRes = AbiParser<SimpleObjects::ObjCategory::Bytes>::
			ToPrimitive<16>(input.begin(), input.end());

		EXPECT_EQ(expRes, actRes);
	}

	// bytes32
	{
		std::vector<uint8_t> input = {
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
			0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
			0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
		};
		auto expRes = std::make_tuple(
			std::vector<uint8_t>({
				0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
				0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
				0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
				0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
			}),
			input.end()
		);

		auto actRes = AbiParser<SimpleObjects::ObjCategory::Bytes>::
			ToPrimitive<32>(input.begin(), input.end());

		EXPECT_EQ(expRes, actRes);
	}

	// Error - not enough bytes (smaller than target type)
	{
		std::vector<uint8_t> input = {
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
		};

		auto testProg = [&input]() {
			AbiParser<SimpleObjects::ObjCategory::Bytes>::
				ToPrimitive<16>(input.begin(), input.end());
		};

		EXPECT_THROW(testProg();, EclipseMonitor::Exception);
	}

	// Error - not enough bytes (smaller than chunk size)
	{
		std::vector<uint8_t> input = {
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
			0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
		};

		auto testProg = [&input]() {
			AbiParser<SimpleObjects::ObjCategory::Bytes>::
				ToPrimitive<16>(input.begin(), input.end());
		};

		EXPECT_THROW(testProg();, EclipseMonitor::Exception);
	}

	// Error - non-zero padding bytes
	{
		std::vector<uint8_t> input = {
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
			0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
		};

		auto testProg = [&input]() {
			AbiParser<SimpleObjects::ObjCategory::Bytes>::
				ToPrimitive<16>(input.begin(), input.end());
		};

		EXPECT_THROW(testProg();, EclipseMonitor::Exception);
	}
}

GTEST_TEST(TestEthAbiParser, ParseDynamicBytesPrimitive)
{
	// bytes dyn 16
	{
		std::vector<uint8_t> input = {
			// len
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x10U,
			// data
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
			0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
		};
		auto expRes = std::make_tuple(
			std::vector<uint8_t>({
				0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
				0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
			}),
			input.end()
		);

		auto actRes = AbiParser<SimpleObjects::ObjCategory::Bytes>::
			ToPrimitive(input.begin(), input.end());

		EXPECT_EQ(expRes, actRes);
	}

	// Error - no enough bytes (smaller than target size)
	{
		std::vector<uint8_t> input = {
			// len
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x10U,
			// data
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
		};

		auto testProg = [&input]() {
			AbiParser<SimpleObjects::ObjCategory::Bytes>::
				ToPrimitive(input.begin(), input.end());
		};

		EXPECT_THROW(testProg();, EclipseMonitor::Exception);
	}

	// Error - no enough bytes (smaller than chunk size)
	{
		std::vector<uint8_t> input = {
			// len
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x10U,
			// data
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
			0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
		};

		auto testProg = [&input]() {
			AbiParser<SimpleObjects::ObjCategory::Bytes>::
				ToPrimitive(input.begin(), input.end());
		};

		EXPECT_THROW(testProg();, EclipseMonitor::Exception);
	}

	// Error - non-zero padding bytes
	{
		std::vector<uint8_t> input = {
			// len
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x10U,
			// data
			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
			0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x01U,
		};

		auto testProg = [&input]() {
			AbiParser<SimpleObjects::ObjCategory::Bytes>::
				ToPrimitive(input.begin(), input.end());
		};

		EXPECT_THROW(testProg();, EclipseMonitor::Exception);
	}
}

GTEST_TEST(TestEthAbiParser, ParseMixParamsPrimitive)
{
	// function bar(
	// 		bool isFoo,
	// 		bytes32 fooBytes,
	// 		uint64 num,
	// 		bytes dynBytes
	// ) public
	{
		std::vector<uint8_t> input = {
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x01U,

			0x48U, 0x65U, 0x6cU, 0x6cU, 0x6fU, 0x2cU, 0x20U, 0x77U,
			0x6fU, 0x72U, 0x6cU, 0x64U, 0x21U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,

			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x45U,

			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x10U,

			0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
			0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
		};

		// destination variables
		bool                 param1;
		std::vector<uint8_t> param2;
		uint64_t             param3;
		std::vector<uint8_t> param4;

		// parse
		auto begin = input.begin();
		std::tie(param1, begin) =
			AbiParser<SimpleObjects::ObjCategory::Bool>::
				ToPrimitive(begin, input.end());
		std::tie(param2, begin) =
			AbiParser<SimpleObjects::ObjCategory::Bytes>::
				ToPrimitive<32>(begin, input.end());
		std::tie(param3, begin) =
			AbiParser<SimpleObjects::ObjCategory::Integer>::
				ToPrimitive<SimpleObjects::RealNumType::UInt64>
					(begin, input.end());
		std::tie(param4, begin) =
			AbiParser<SimpleObjects::ObjCategory::Bytes>::
				ToPrimitive(begin, input.end());

		// check parsed values
		EXPECT_EQ(param1, true);
		EXPECT_EQ(param2,
			std::vector<uint8_t>({
				0x48U, 0x65U, 0x6cU, 0x6cU, 0x6fU, 0x2cU, 0x20U, 0x77U,
				0x6fU, 0x72U, 0x6cU, 0x64U, 0x21U, 0x00U, 0x00U, 0x00U,
				0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
				0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			})
		);
		EXPECT_EQ(param3, 0x45U);
		EXPECT_EQ(param4,
			std::vector<uint8_t>({
				0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xABU, 0xCDU, 0xEFU,
				0xEFU, 0xCDU, 0xABU, 0x89U, 0x67U, 0x45U, 0x23U, 0x01U,
			})
		);

		// check if all input is consumed
		EXPECT_EQ(begin, input.end());
	}
}
